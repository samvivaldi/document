chapter 1

외부 프로퍼티(application.properties) 사용하기
  - 자바 소스 보다 외부 프로퍼티 설정이 우선순위가 높다
spring banner 끄기
  - spring.main.banner-mode=off
  - server.port=8080

웹애플리케이션 작성  
  - @SpringBootApplication에 포함된 @ComponentScan은 메인 클래스가 속해 있는 패키지를 베이스 패키지로 처리한다. 
  - OtherController 클래스 작성 후, @ComponentScan을 재정의한다. 
    @ComponentScan(basePackages={"com.rubypaper", "com.ruby"})
    @ComponentScan(basePackages={"com.rubypaper,tv"})
   
-----------------------    
chapter 2   

스프링 부트는 “spring-boot-starter-모듈명” 형태의 다양한 스타터를 제공한다. 

메인 애플리케이션을 실행하면 스프링 부트는 무조건 메인 애플리케이션에 설정된 @SpringBootApplication을 로딩한다. 

@SpringBootApplication은 세 개의 어노테이션(@ComponentScan, @SpringBootConfiguration, @EnableAutoConfiguration)으로 대체할 수 있다.

자동 설정 설정파일 위치
  - @EnableAutoConfiguration 은 spring-boot-autoconfigure-2.1.5.RELEASE.jar 파일에 포함되어 있다. 
  - @EnableAutoConfiguration 은 spring.factories (/META-INF/spring.factories) 파일에 등록된 자동설정 클래스들을 로딩한다.
  
WebMvcAutoConfiguration 설정 클래스

자동 설정 어노테이션
  - @ConditionalOnWebApplication  
    웹 애플리케이션 타입을 체크하여 현재 설정 클래스를 적용 (Main 클래스의 WebApplicationType 설정 확인)
  - @ConditionalOnClass  
    특정 클래스가 클래스 패스에 존재할 때, 현재 설정 클래스를 적용  
  - @ConditionalOnMissingBean  
    특정 객체가 메모리에 없을 때, 현재 설정 클래스를 적용 
  - @AutoConfigureOrder  
    자동 설정 클래스의 우선 순위를 지정(Ordered.HIGHEST_PRECEDENCE + 10은 가장 높은 우선 순위보다 10단계 높게 설정) 
  - @AutoConfigureAfter  
    현재의 설정 클래스가 지정된 다른 설정 클래스 다음에 적용되도록 지정 

자동 설정 로그 확인
  - run 할때 Arguments 에  --debug 추가
  
사용자 정의 스타터
  - 스타터는 의존성을 자동으로 관리하며, 자동설정은 애플리케이션 운용에 필요한 빈들을 초기화한다. 
  - 스프링 부트 프로젝트에서 특정 도메인이나 비즈니스에 최적화된 스타터와 자동완성을 만들면 쉽게 프로젝트를 생성하고 관리할 수 있다. 
  - 사용자 정의 스타터는 ‘XXX-spring-boot-starter’ 같은 이름 패턴을 따른다. 

----------------------
BoardAutoConfiguration 구현

package com.samjava.jdbc.util
@Configuration
public class BoardAutoConfiguration {

	@Bean
	public JDBCConnectionManager getJDBCConnectionManager() {
	
	}
}

src/main/resource/Spring.factories 파일에  com.samjava.jdbc.util.BoardAutoConfiguration 추가, build하여 jar파일 생성


7. 사용자 정의 스타터 사용하기 (pom.xml에 dependency 추가후)
@Autowired
private JDBCConnectionManager connectionManager;

----------------------
project에서 아래를 다시 생성하면 
메모리에 JDBCConnectionManager 타입의 빈이 두 개가 등록되기 때문에 에러 발생! (자동 설정으로 생성된 빈과 새롭게 등록된 빈 충돌)

@Configuration
public class BoardAutoConfiguration {

	@Bean
	public JDBCConnectionManager getJDBCConnectionManager() {
	
	}
}

spring.main.allow-bean-definition-overriding=true  <-- 새롭게 생성된 빈이 이전에 생성된 빈을 Overwriting하도록 설정한다. 

스프링 부트는 @ComponentScan으로 사용자가 등록한 빈을 먼저 메모리에 올린다. 
그리고 나서 @EnableAutoConfiguration을 실행하여 자동설정에 의한 빈 등록을 처리한다.

@Conditional 어노테이션을 사용하여 조건에 따라 빈 등록을 처리하면 재정의된 빈이 우선순위가 높아진다.

  - @ConditionalOnMissingBean  
    특정 객체가 메모리에 없을 때, 현재 설정 클래스를 적용 
    
----------------------    
프로퍼티 이용하기    
@ConfigurationProperties를 이용하면 application.properties 파일에 등록된(post.jdbc로 시작하는) 프로퍼티 정보를 사용할 수 있다. 

@ConfigurationProperties(prefix="post.jdbc")
public class JDBCConnectionManagerProperties {
	private String url;
}

dependency추가  (ConfigurationProperties 를 사용하기 위해)

		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-configuration-processor</artifactId>
			<optional>true</optional>
		</dependency>


@Configuration
@EnableConfigurationProperties(JDBCConnectionManagerProperties.class)
public class BoardAutoConfiguration {
		
  @Autowired
  private JDBCConnectionManagerProperties properties;		
  
	@Bean
	public JDBCConnectionManager getJDBCConnectionManager() {
		 properties.getUrl(); 
		
	}
}


application.properties 파일
  spring.main.allow-bean-definition-overriding=true

  post.jdbc.url=
  post.jdbc.driverClass=
  
  
-----------------------    
chapter 3 테스트와 로깅, 빌드

@SpringBootTest 
  - properties 테스트에 사용할 프로퍼티를 ‘key=value’ 형태로 추가하거나 기존에 설정되었던 프로퍼티를 재정의한다
  - classes 테스트할 클래스들을 등록한다. 만일 classes 속성을 생략하면 애플리케이션에 정의된 모든 빈을 생성한다.
  - webEnvironment 애플리케이션이 실행될 때, 웹과 관련된 환경을 설정할 수 있다. 
  참고 : classes 속성과 webEnvironment 속성은 같이 사용할 수 없다
 
@SpringBootTest(properties= {"author.name=sam",
                              author.age=50"})
public class PropertiesTest {

	@Autowired
	Environment environment;
	
	@Test
	public void testMethod() {
		 environment.getProperty("author.name");
	}
}               


목(Mock)의 사전적 의미는 ‘테스트를 위해 만든 모형’이다. 

테스트를 위해 모의 객체를 만드는 것을 모킹(Mocking)이라 하며, 모킹한 객체를 얻어내는 과정을 목업(Mock up)이라 한다. 

서블릿 컨테이너 목킹(Mocking) 
  - 웹 환경에서 컨트롤러를 테스트하려면 반드시 서블릿 컨테이너가 구동되고 DispatcherServlet 객체가 메모리에 올라가야 한다. 
  - 서블릿 컨테이너를 모킹하면 테스트용 모의 컨테이너를 사용하기 때문에 실제 서블릿 컨테이너 없이도 컨트롤러를 테스트할 수 있다.
  - 서블릿 컨테이너를 모킹하기 위해서는 @WebMvcTest나 @AutoConfigureMockMvc를 사용한다. 
    
@WebMvcTest는 @Controller, @RestController 객체들만 초기화한다. 
반면 @AutoConfigureMockMvc는 @Service, @Repository 까지 모두 초기화한다.

--------------------------------------------------

Chapter06 스프링 부트 화면 개발

자바는 시스템에서 발생되는 문제를 에러(Error)와 예외(Exception)로 구분한다. 

스프링에서는 @ControllerAdvice나 @ExceptionHandler를 이용하여 예외를 처리한다. 

@ControllerAdvice는 모든 컨트롤러에서 발생하는 예외를 일괄적으로 처리할 때 사용한다.  

@ExceptionHandler는 각 컨트롤러마다 발생하는 예외를 개별적으로 처리할 때 사용한다

--------------------------------------------------

Chapter07

스프링 시큐리티 동작 원리

시큐리티 필터 중에서 사용자가 입력한 인증 정보를 이용해서 인증을 처리하는 UsernamePasswordAuthenticationFilter가 가장 중요하다.

그리고 FilterSecurityInterceptor는 인증에 성공한 사용자가 해당 리소스에 접근할 권한이 있는지 검증한다. 
